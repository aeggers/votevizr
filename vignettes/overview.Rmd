---
title: "Overview of `votevizr` package"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{overview}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.retina = 5,
  fig.align = "center"
)
```

The `votevizr` package provides tools to represent election results in ordinal voting systems, i.e. systems in which voters rank candidates. This class of systems includes: 

- positional methods (plurality, Borda count, anti-plurality, and more)
- Condorcet methods
- ranked-choice voting (aka RCV, instant runoff voting/IRV, alternative vote/AV, one-winner STV, preferential voting, ...)
- and a few more.

For positional methods, these tools make sense only for three-candidate elections. For Condorcet and RCV, they can also be used when there is an identifiable top three candidates.   


```{r setup, results = "hide", message = F, warning = F}
library(tidyverse)
library(votevizr)
```

# Code example: a Brexit poll

In November 2018, YouGov ran a [poll](https://yougov.co.uk/topics/politics/articles-reports/2018/12/06/mays-brexit-deal-leads-just-two-constituencies-it-) in which UK respondents were asked to rank three options for the UK's future relationship with the EU. Those options were 

- remain in the EU ("Remain"), 
- accept Theresa May's deal ("Deal"), or 
- leave the EU without a deal ("No deal"). 

UK-wide, Ben Lauderdale [estimated](https://d25d2506sfb94s.cloudfront.net/cumulus_uploads/document/24pikzv1u7/Ben%20Lauderdale%20Brexit%20deal%20MRP%20report.pdf) that the proportions for each preference ordering were: 

```{r brexit_orderings, echo = T}
brexit_result <- list("Remain > Deal > No deal" = .375, 
               "No deal > Deal > Remain" = .228, 
               "Deal > No deal > Remain" = .212, 
               "Remain > No deal > Deal" = .087, 
               "Deal > Remain > No deal" = .059, 
               "No deal > Remain > Deal" = .038)
data.frame("Ranking" = names(brexit_result), 
           "Proportion" = unlist(brexit_result),
           row.names = NULL) %>% 
  knitr::kable()
```

As explained in detail in my [paper](http://andy.egge.rs/papers/diagramming_election_results_v7_for_RR2.pdf) (accepted at *Social Choice and Welfare*), it can be useful to have a diagram that shows how ordinal preference data like this produces a winner in various voting systems. 

The difficulty is that the poll result is a 5-dimensional object (6 proportions that sum to 1), so we have to simplify it somehow to make a useful diagram. (If incomplete orderings were possible, there could be 8 dimensions.) 

Briefly, my approach is to map *first preference shares* (proportion of top rankings each alternative receives) onto the $x$ and $y$ dimensions, either in standard coordinates or barycentric/ternary coordinates. The key innovation is to also divide the space of possible first-preference shares according to who *would have* won given the voting system being considered and the observed pattern of second preferences. 

I refer to the set of first-preference results in which a given candidate would have won (given the voting system and pattern of lower preferences) a *first-preference win region*. `votevizr`'s key function converts an ordinal election result, organized as a named list like `brexit_result` above, into a tidy data frame of vertices for each candidate's first-preference win region.    

We illustrate with plurality, the simplest ordinal method:

```{r brexit_illustration_1, echo = T}
brexit_plurality_fpwr <- brexit_result %>% 
  first_preference_win_regions(split = " > ", method = "plurality")

brexit_plurality_fpwr %>% knitr::kable()
```

Each row in `brexit_plurality_fpwr` provides the coordinates for a vertex on the first preference win region of a candidate (specified in the `candidate` column).

Because the data is in "tidy" format, we can easily plot the first-preference win regions in `ggplot2`. 

First, standard coordinates: 

```{r plot_brexit_standard}
brexit_plurality_fpwr %>% 
  ggplot(aes(x = `No deal`, y = Deal)) +
  geom_polygon(aes(group = candidate, fill = candidate), show.legend = F) +
  coord_fixed() + 
  scale_fill_brewer()
```

I prefer barycentric or ternary coordinates, because it treats the three alternatives more symmetrically. You could use the `ggtern` package, but it overwrites a lot of `ggplot` methods (making it difficult to switch back and forth between standard and ternary coordinates). It's surprisingly easy to make a ternary plot without it, so I chose that route. 

To convert data in $(x, y, z)$ coordinates into ternary coordinates $(x', y')$, the transformation is
\begin{eqnarray}
x' &:=& x + \frac{1}{2}y \\
y' &:=& \frac{\sqrt{3}}{2} y. \\
\end{eqnarray} 

So first I do the transformation:
```{r brexit_ternary_transform}
brexit_plurality_fpwr %>% 
  mutate(`No deal` = `No deal` + .5*Deal, Deal = sqrt(3/4)*Deal) ->
  brexit_plurality_fpwr_ternary
```

Then plot it:
```{r plot_brexit_ternary}
brexit_plurality_fpwr_ternary %>%
  ggplot(aes(x = `No deal`, y = Deal)) +
  geom_polygon(aes(group = candidate, fill = candidate), show.legend = F) +
  coord_fixed() + 
  scale_fill_brewer() + 
  theme_void() + 
  expand_limits(x = c(-.1, 1.1), y = sqrt(3/4)*c(-.1, 1.1)) + 
  annotate(geom = "text", x = c(1,.5,0), y = c(0,sqrt(3/4),0) + .05*c(-1,1,-1), label = c("No deal", "Deal", "Remain")) -> p
p
```
We can also add a dot for the observed result, using the `votevizr::first_preference_shares()` method to extract the observed first-preference shares: 
```{r brexit_with_result}
brexit_fps <- brexit_result %>% 
  first_preference_shares(split = " > ") %>% 
  mutate(`No deal` = `No deal` + .5*Deal, Deal = sqrt(3/4)*Deal)

p + geom_point(data = brexit_fps, aes(x = `No deal`, y = Deal))
```
So the plurality winner is "Remain"! 

This may not be so enlightening for plurality, but just by changing the arguments to `first_preference_win_regions()` we can get one of several other election methods. 

First we're going to store the added layers from the plot in a list:
```{r gglist_storage}
layer_list <- list(
  geom_polygon(aes(group = candidate, fill = candidate), show.legend = F),
  coord_fixed(), 
  scale_fill_brewer(), 
  theme_void(),
  expand_limits(x = c(-.1, 1.1), y = sqrt(3/4)*c(-.1, 1.1)), 
  annotate(geom = "text", x = c(1,.5,0), y = c(0,sqrt(3/4),0) + .05*c(-1,1,-1), label = c("No deal", "Deal", "Remain")),
  geom_point(data = brexit_fps, aes(x = `No deal`, y = Deal))
)
```

Now here's the Borda plot:   

```{r borda_brexit, echo = T}
brexit_result %>% 
  first_preference_win_regions(split = " > ", method = "borda") %>%
  mutate(`No deal` = `No deal` + .5*Deal, Deal = sqrt(3/4)*Deal) %>%
  ggplot(aes(x = `No deal`, y = Deal)) +
  layer_list
```

Ranked-choice voting: 

```{r rcv_brexit, echo = T}
brexit_result %>% 
  first_preference_win_regions(split = " > ", method = "IRV") %>%
    mutate(`No deal` = `No deal` + .5*Deal, Deal = sqrt(3/4)*Deal) %>%
  ggplot(aes(x = `No deal`, y = Deal)) +
  layer_list
```

Or the Kemeny-Young method: 
```{r condorcet_brexit, echo = T}
brexit_result %>% 
  first_preference_win_regions(split = " > ", method = "Condorcet", if_cycle = "kemeny") %>%
    mutate(`No deal` = `No deal` + .5*Deal, Deal = sqrt(3/4)*Deal) %>%
  ggplot(aes(x = `No deal`, y = Deal)) +
  layer_list -> p
p
```

Let's add gridlines! 

```{r gridlines}
one_line <- function(val, cnames){
  out <- data.frame(rbind(c(val, 1 - val, 0),
        c(val, 0, 1 - val)))
  colnames(out) <- cnames
  out
}

one_df <- function(val, line_colnames = c("x", "y", "z")){
  data <- tibble(value = val,
                     one_line(val, line_colnames))
  data
}  

gridlines_df_for_one <- function(vals, line_colnames = c("x", "y", "z")){
  tibble(val = vals) %>% 
    purrr::pmap(one_df, line_colnames = line_colnames) %>% 
    bind_rows()
}

gridlines_df <- function(vals = c(.25, .5, .75)){
  g1 <- gridlines_df_for_one(vals)
  bind_rows(
    g1 %>% mutate(vertex = "x"),
    g1 %>% mutate(vertex = "y") %>% 
      select(vertex, value, x = y, y = x, z),
    g1 %>% mutate(vertex = "z") %>% 
      select(vertex, value, x = z, y, z = x)
  ) %>% select(vertex, everything())
}

p + geom_line(data = gridlines_df() %>% mutate(x = x + .5*y, y = sqrt(3/4)*y), aes(x = x, y = y, linetype = vertex, group = interaction(vertex, value)), show.legend = F, alpha = .75, col = "darkgray")
```

## San Francisco mayoral election 2018

```{r sf_stuff, echo = T, fig.retina=5, fig.align = "center", out.width = "50%", fig.width = 5}
sf_result <- list(
  "Breed_Leno" = .149,
  "Breed_Kim" = .108,
  "Breed" = .176,
  "Leno_Breed" = .083,
  "Leno_Kim" = .147,
  "Leno" = .059,
  "Kim_Breed" = .056,
  "Kim_Leno" = .188,
  "Kim" = .034
)

sf_fpwr_kemeny <- first_preference_win_regions(sf_result, split = "_", method = "Condorcet", if_cycle = "kemeny")

sf_fps <- first_preference_shares(sf_result, split = "_")

# standard coordinates 
ggplot(sf_fpwr_kemeny, aes(x = Breed, y = Leno)) + 
  geom_polygon(aes(group = candidate, fill = candidate), show.legend = T, col = "black") + 
  coord_fixed() + 
  scale_fill_brewer() + 
  labs(x = "Breed first-preference share", y = "Leno first-preference share", fill = "Winning\ncandidate") + 
  geom_point(data = sf_fps, aes(x = Breed, y = Leno))
  
# quasi ternary 
padding <- .05
first_preference_win_regions(sf_result, split = "_", method = "IRV", s = 1, if_cycle = "empty") %>% 
  mutate(Breed = Breed + .5*Leno,
         Leno = sqrt(3/4)*Leno) %>%
ggplot(aes(x = Breed, y = Leno)) + 
  geom_polygon(aes(group = candidate, fill = candidate), show.legend = F, col = "black") + 
  theme_void() + 
  coord_fixed() +
  scale_fill_brewer() + 
  expand_limits(x = c(-.1, 1.1), y = sqrt(3/4)*c(-.1, 1.1)) + 
  annotate(geom = "text", x = c(1,.5,0), y = c(0,sqrt(3/4),0) + padding*c(-1,1,-1), label = c("Breed", "Leno", "Kim")) + 
  geom_point(data = sf_fps %>% mutate(Breed = Breed + .5*Leno,
                                      Leno = sqrt(3/4)*Leno), aes(x = Breed, y = Leno))

```

## Want to know more?

Read my paper, forthcoming in *Social Choice and Welfare* (preprint [here](http://andy.egge.rs/papers/diagramming_election_results_v7_for_RR2.pdf)), which explains the figures in more detail and discusses previous attempts to represent election results in ternary diagrams.    
  